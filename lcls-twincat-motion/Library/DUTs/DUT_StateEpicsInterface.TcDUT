<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <DUT Name="DUT_StateEpicsInterface" Id="{233f01d3-5e73-4c09-b009-203daf86cb72}">
    <Declaration><![CDATA[TYPE DUT_StateEpicsInterface :
(*
    This data structure contains the standard EPICS connection points for the state movers.

    It includes everything except the GET and SET PVs, which cannot be included here
    as they are sourced from enum values unique to the application, and the array PVs,
    which can be an array of various lengths.

    Placeholders for GET and SET are included here, with commented-out pragmas that
    demonstrate what they would look like if we could include them.
    These placeholders are actively used by state blocks even though they are not exposed
    directly to EPICS. You are expected to set the SET placeholder using your EPICS-linked
    SET enum and then after running the state block, set your EPICS-linked GET enum
    using the GET placeholder.

    A placeholder for the array is included here just to show what the pragma would be,
    but it is commented out as it will not be used in the program.
    The example array assumes a 1D state mover. For multidimensional state movers,
    you should pragma multiple arrays numerically (01, 02, 03, ...) rather than leaving
    the pv field blank.
*)
STRUCT
    // Get your enum value from this value at the end of the cycle.
    (*
    Example of what the pragma would be if we had your enum:
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    *)
    nGetValue: INT;
    // Set this from your enum value at the start of the cycle.
    (*
    Example of what the pragma would be if we had your enum:
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    *)
    nSetValue: INT;

    // This will be TRUE when we are in an active state move and FALSE otherwise.
    {attribute 'pytmc' := '
        pv: BUSY
        io: i
        field: ZNAM False
        field: ONAM True
    '}
    bBusy: BOOL;
    // This will be TRUE after a move completes and FALSE otherwise.
    {attribute 'pytmc' := '
        pv: DONE
        io: i
        field: ZNAM False
        field: ONAM True
    '}
    bDone: BOOL;
    // This will be TRUE if the most recent move had an error and FALSE otherwise.
    {attribute 'pytmc' := '
        pv: ERR
        io: i
        field: ZNAM False
        field: ONAM True
    '}
    bError: BOOL;
    // This will be set to an NC error code during an error if one exists or left at 0 otherwise.
    {attribute 'pytmc' := '
        pv: ERRID
        io: i
    '}
    nErrorID: UDINT;
    // This will be set to an appropriate error message during an error if one exists or left as an empty string otherwise.
    {attribute 'pytmc' := '
        pv: ERRMSG
        io: i
    '}
    sErrorMsg: STRING;
    // Set this to TRUE to acknowledge and clear an error.
    {attribute 'pytmc' := '
        pv: RESET
        io: io
        field: ZNAM False
        field: ONAM True
    '}
    bReset: BOOL;

    // This should be the canonical source for the live, active states array
    (*
    Example of what the pragma would be if we had your arrStates:
    {attribute 'pytmc' := '
        pv:
        io: io
        expand: %.2d
    '}
    arrStates: ARRAY[1..GeneralConstants.MAX_STATES] OF DUT_PositionState
    *)
END_STRUCT
END_TYPE
]]></Declaration>
  </DUT>
</TcPlcObject>