<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_MotionHoming" Id="{89795143-e01c-4e96-8d50-67b6176895fe}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotionHoming
VAR_IN_OUT
    stMotionStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    bExecute: BOOL;
END_VAR
VAR
    fbSetPos: MC_SetPosition;
    fbJog: MC_Jog;
    rtExec: R_TRIG;
    nHomeStateMachine: INT := IDLE;
    nMoves: INT;
    bFirstDirection: BOOL;
    bAtHome: BOOL;
    bMove: BOOL;
END_VAR
VAR CONSTANT
    IDLE: INT := 0;
    NEXT_MOVE: INT := 1;
    CHECK_FWD: INT := 2;
    CHECK_BWD: INT := 3;
    FINAL_MOVE: INT := 4;
    FINAL_SETPOS: INT := 5;
    ERROR: INT := 5;
    
    FWD_START: LREAL := -99999999;
    BWD_START: LREAL :=  99999999;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
fbSetPos.Options.ClearPositionLag := TRUE;
rtExec(CLK:=bExecute);

CASE stMotionStage.nHomingMode OF
    ENUM_EpicsHomeCmd.LOW_LIMIT:
        bFirstDirection := FALSE;
        bAtHome := NOT stMotionStage.bLimitBackwardEnable;
        bMove := TRUE;
    ENUM_EpicsHomeCmd.HIGH_LIMIT:
        bFirstDirection := TRUE;
        bAtHome := NOT stMotionStage.bLimitForwardEnable;
        bMove := TRUE;
    ENUM_EpicsHomeCmd.HOME_VIA_LOW:
        bFirstDirection := FALSE;
        bAtHome := stMotionStage.bHome;
        bMove := TRUE;
    ENUM_EpicsHomeCmd.HOME_VIA_HIGH:
        bFirstDirection := TRUE;
        bAtHome := stMotionStage.bHome;
        bMove := TRUE;
    ENUM_EpicsHomeCmd.ABSOLUTE_SET:
        fbSetPos(
            Axis:=stMotionStage.Axis,
            Execute:=bExecute,
            Position:=stMotionStage.fHomePosition);
        bMove := FALSE;
    ELSE
        bMove := FALSE;
END_CASE

IF bMove THEN
    CASE nHomeStateMachine OF
        // Wait for a rising edge
        IDLE:
            IF rtExec.Q THEN
                nHomeStateMachine := NEXT_MOVE;
                nMoves := 0;
			END_IF
        // Figure out whether to move forward, move backward, or give up
        NEXT_MOVE:
            fbSetPos(
                Axis:=stMotionStage.Axis,
                Execute:=FALSE);
            fbJog(
                Axis:=stMotionStage.Axis,
                JogForward:=FALSE,
                JogBackwards:=FALSE);
            CASE nMoves OF
                0:
                    IF bFirstDirection THEN
                        nHomeStateMachine := CHECK_FWD;
                    ELSE
                        nHomeStateMachine := CHECK_BWD;
					END_IF
                1:
                    IF NOT bFirstDirection THEN
                        nHomeStateMachine := CHECK_FWD;
                    ELSE
                        nHomeStateMachine := CHECK_BWD;
					END_IF
                ELSE
                    nHomeStateMachine := ERROR;
			END_CASE
            nMoves := nMoves + 1;
            IF bAtHome THEN
                nHomeStateMachine := FINAL_MOVE;
			END_IF
        // Move forward until we find the home signal or reach end of travel
        CHECK_FWD:
            fbSetPos(
                Axis:=stMotionStage.Axis,
                Execute:=TRUE,
                Position:=FWD_START);
            fbJog(
                Axis:=stMotionStage.Axis,
                JogForward:=stMotionStage.bLimitForwardEnable AND NOT bATHome,
                JogBackwards:=FALSE,
                Mode:=E_JogMode.MC_JOGMODE_CONTINOUS,
                Velocity:=stMotionStage.stAxisParameters.fRefVeloSearch);
            IF fbJog.Error THEN
                nHomeStateMachine := ERROR;
            ELSIF bATHome THEN
                nHomeStateMachine := FINAL_MOVE;
            ELSIF NOT fbJog.JogForward THEN
                nHomeStateMachine := NEXT_MOVE;
			END_IF
        // Move backward until we find the home signal or reach end of travel
        CHECK_BWD:
            fbSetPos(
                Axis:=stMotionStage.Axis,
                Execute:=TRUE,
                Position:=BWD_START);
            fbJog(
                Axis:=stMotionStage.Axis,
                JogForward:=FALSE,
                JogBackwards:=stMotionStage.bLimitBackwardEnable AND NOT bATHome,
                Mode:=E_JogMode.MC_JOGMODE_CONTINOUS,
                Velocity:=stMotionStage.stAxisParameters.fRefVeloSearch);
            IF fbJog.Error THEN
                nHomeStateMachine := ERROR;
            ELSIF NOT fbJog.JogBackwards THEN
                nHomeStateMachine := NEXT_MOVE;
			END_IF
        // Set position to get within soft lims, move slowly off signal
        FINAL_MOVE:
            fbSetPos(
                Axis:=stMotionStage.Axis,
                Execute:=TRUE,
                Position:=stMotionStage.fHomePosition);
            IF bAtHome THEN
                fbJog(
                    Axis:=stMotionStage.Axis,
                    JogForward:=NOT bFirstDirection,
                    JogBackwards:=bFirstDirection,
                    Mode:=E_JogMode.MC_JOGMODE_CONTINOUS,
                    Velocity:=stMotionStage.stAxisParameters.fRefVeloSync);
            ELSE
                fbJog(
                    Axis:=stMotionStage.Axis,
                    JogForward:=FALSE,
                    JogBackwards:=FALSE);
                fbSetPos(
                    Axis:=stMotionStage.Axis,
                    Execute:=FALSE);
                nHomeStateMachine := FINAL_SETPOS;
            END_IF
        FINAL_SETPOS:
            fbSetPos(
                Axis:=stMotionStage.Axis,
                Execute:=TRUE,
                Position:=stMotionStage.fHomePosition);
            nHomeStateMachine := IDLE;
        ERROR:
            nHomeStateMachine := IDLE;
	END_CASE
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>