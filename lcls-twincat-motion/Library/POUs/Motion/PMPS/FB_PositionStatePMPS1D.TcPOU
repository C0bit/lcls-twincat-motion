<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_PositionStatePMPS1D" Id="{56571b82-7366-43ed-8860-8bf7f745d798}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PositionStatePMPS1D
(*
    1-Dimensional position state function block with PMPS.

    You can use this in your project by defining enums as explained in ST_StateEpicsinput and ST_StateEpicsOutput's docstrings.
    Your "command" enum should write to stEpicsInput.nSetValue and your "readback" enum should read from stEpicsOutput.nGetValue.

    This represents one motor moving among named states.
    When nSetValue changes, a move is made.
    The motor must already be set up for point-to-point motion for this function block to work properly.

    PMPS handling is done via database lookups by setting sPmpsState on each position state and on
    the transition state input appropriately.
*)
VAR_IN_OUT
    stMotionStage: ST_MotionStage;
    {attribute 'pytmc' := '
        pv: STATES
        io: io
        expand: %.2d
    '}
    astPositionState: ARRAY[1..GeneralConstants.MAX_STATES] OF ST_PositionState;
    eEnumInput: INT;
    eEnumOutput: INT;
    fbFFHWO: FB_HardwareFFOutput;
    fbArbiter: FB_Arbiter;
END_VAR
VAR_INPUT
    bEnableMotion: BOOL;
    bEnableBeamParams: BOOL;
    bEnablePositionLimits: BOOL;
    sDeviceName: STRING;
    sTransitionKey: STRING;
    {attribute 'pytmc' := '
        pv: STATES
        io: io
    '}
    stEpicsInput: ST_StateEpicsInput;
    {attribute 'pytmc' := '
        pv: STATES
        io: io
    '}
    stPMPSEpicsInput: ST_StatePMPSEpicsInput;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: STATES
        io: i
    '}
    stEpicsOutput: ST_StateEpicsOutput;
    {attribute 'pytmc' := '
        pv: STATES
        io: i
    '}
    stPMPSEpicsOutput: ST_StatePMPSEpicsOutput;
    stDbStateParams: ST_DbStateParams;
END_VAR
VAR
    fbCore: FB_PositionStateND_Core;
    fbPMPSCore: FB_PositionStatePMPSND_Core;
    astMotionStageMax: ARRAY[1..MotionConstants.MAX_STATE_MOTORS] OF ST_MotionStage;
    astPositionStateMax: ARRAY[1..MotionConstants.MAX_STATE_MOTORS] OF ARRAY[1..GeneralConstants.MAX_STATES] OF ST_PositionState;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
astMotionStageMax[1] := stMotionStage;
astPositionStateMax[1] := astPositionState;

fbCore(
    astMotionStageMax:=astMotionStageMax,
    astPositionStateMax:=astPositionStateMax,
    stEpicsInput:=stEpicsInput,
    stEpicsOutput:=stEpicsOutput,
    eEnumInput:=eEnumInput,
    eEnumOutput:=eEnumOutput,
    bEnable:=bEnableMotion,
    nActiveMotorCount:=1,
    nCurrGoal=>,
);
fbPMPSCore(
    astMotionStageMax:=astMotionStageMax,
    astPositionStateMax:=astPositionStateMax,
    stEpicsInput:=stEpicsInput,
    stPMPSEpicsInput:=stPMPSEpicsInput,
    stEpicsOutput:=stEpicsOutput,
    stPMPSEpicsOutput:=stPMPSEpicsOutput,
    fbFFHWO:=fbFFHWO,
    fbArbiter:=fbArbiter,
    bEnableBeamParams:=bEnableBeamParams,
    bEnablePositionLimits:=bEnablePositionLimits,
    nActiveMotorCount:=1,
    sDeviceName:=sDeviceName,
    sTransitionKey:=sTransitionKey,
    nCurrGoal:=fbCore.nCurrGoal,
    stDbStateParams=>stDbStateParams,
);

stMotionStage := astMotionStageMax[1];
astPositionState := astPositionStateMax[1];
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>