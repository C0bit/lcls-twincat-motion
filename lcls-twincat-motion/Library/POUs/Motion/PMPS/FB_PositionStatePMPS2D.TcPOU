<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_PositionStatePMPS2D" Id="{9dffd600-2d32-4e33-bb6b-8aab4cc29ee5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PositionStatePMPS2D
(*
    2-Dimensional position state function block with PMPS.

    You can use this in your project by defining enums as explained in ST_StateEpicsinput and ST_StateEpicsOutput's docstrings.
    Your "command" enum should write to stEpicsInput.nSetValue and your "readback" enum should read from stEpicsOutput.nGetValue.

    This represents one motor moving among named states.
    When nSetValue changes, a move is made.
    The motor must already be set up for point-to-point motion for this function block to work properly.

    PMPS handling is done via database lookups by setting sPmpsState on each position state and on
    the transition state input appropriately.
*)
VAR_IN_OUT
    stMotionStage1: ST_MotionStage;
    {attribute 'pytmc' := '
        pv: STATES:M1
        io: io
        expand: %.2d
    '}
    astPositionState1: ARRAY[1..GeneralConstants.MAX_STATES] OF ST_PositionState;
    stMotionStage2: ST_MotionStage;
    {attribute 'pytmc' := '
        pv: STATES:M2
        io: io
        expand: %.2d
    '}
    astPositionState2: ARRAY[1..GeneralConstants.MAX_STATES] OF ST_PositionState;
    eEnumInput: DINT;
    eEnumOutput: DINT;
    fbFFHWO: FB_HardwareFFOutput;
    fbArbiter: FB_Arbiter;
END_VAR
VAR_INPUT
    bEnableMotion: BOOL;
    bEnableBeamParams: BOOL;
    bEnablePositionLimits: BOOL;
    sDeviceName: STRING;
    sTransitionKey: STRING;
    {attribute 'pytmc' := '
        pv: STATES
        io: io
    '}
    stEpicsInput: ST_StateEpicsInput;
    {attribute 'pytmc' := '
        pv: STATES
        io: io
    '}
    stPMPSEpicsInput: ST_StatePMPSEpicsInput;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: STATES
    '}
    stEpicsOutput: ST_StateEpicsOutput;
    {attribute 'pytmc' := '
        pv: STATES
        io: i
    '}
    stPMPSEpicsOutput: ST_StatePMPSEpicsOutput;
    stDbStateParams: ST_DbStateParams;
END_VAR
VAR
    fbCore: FB_PositionStateND_Core;
    fbPMPSCore: FB_PositionStatePMPSND_Core;
    astMotionStageMax: ARRAY[1..MotionConstants.MAX_STATE_MOTORS] OF ST_MotionStage;
    astPositionStateMax: ARRAY[1..MotionConstants.MAX_STATE_MOTORS] OF ARRAY[1..GeneralConstants.MAX_STATES] OF ST_PositionState;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
astMotionStageMax[1] := stMotionStage1;
astMotionStageMax[2] := stMotionStage2;
astPositionStateMax[1] := astPositionState1;
astPositionStateMax[2] := astPositionState2;

fbCore(
    astMotionStageMax:=astMotionStageMax,
    astPositionStateMax:=astPositionStateMax,
    stEpicsInput:=stEpicsInput,
    stEpicsOutput:=stEpicsOutput,
    eEnumInput:=eEnumInput,
    eEnumOutput:=eEnumOutput,
    bEnable:=bEnableMotion,
    nActiveMotorCount:=2,
    nCurrGoal=>,
);
fbPMPSCore(
    astMotionStageMax:=astMotionStageMax,
    astPositionStateMax:=astPositionStateMax,
    stEpicsInput:=stEpicsInput,
    stPMPSEpicsInput:=stPMPSEpicsInput,
    stEpicsOutput:=stEpicsOutput,
    stPMPSEpicsOutput:=stPMPSEpicsOutput,
    fbFFHWO:=fbFFHWO,
    fbArbiter:=fbArbiter,
    bEnableBeamParams:=bEnableBeamParams,
    bEnablePositionLimits:=bEnablePositionLimits,
    nActiveMotorCount:=2,
    sDeviceName:=sDeviceName,
    sTransitionKey:=sTransitionKey,
    nCurrGoal:=fbCore.nCurrGoal,
    stDbStateParams=>stDbStateParams,
);

stMotionStage1 := astMotionStageMax[1];
stMotionStage2 := astMotionStageMax[2];
astPositionState1 := astPositionStateMax[1];
astPositionState2 := astPositionStateMax[2];
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>